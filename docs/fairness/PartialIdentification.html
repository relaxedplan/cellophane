<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fairness.PartialIdentification API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fairness.PartialIdentification</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
import numpy as np

import metrics
from utils import compute_lower_bound, compute_upper_bound, truncate, compute_expected_outcome

from constants import *


class PartialIdentification:
    def __init__(
            self,
            primary_dataset,
            auxiliary_dataset,
            primary_ground_truth_col,
            primary_features_col,
            protected_class_col,
            prediction_col,
            proxies_col,
    ):
        &#34;&#34;&#34;

        :param primary_dataset:
        :type primary_dataset:
        :param auxiliary_dataset:
        :type auxiliary_dataset:
        :param primary_ground_truth_col:
        :type primary_ground_truth_col:
        :param primary_features_col:
        :type primary_features_col:
        :param protected_class_col:
        :type protected_class_col:
        :param prediction_col:
        :type prediction_col:
        :param proxies_col:
        :type proxies_col:
        &#34;&#34;&#34;
        assert primary_ground_truth_col in primary_dataset.columns
        assert all(f in primary_dataset.columns for f in primary_features_col)
        assert all(p in primary_dataset.columns for p in proxies_col)
        assert all(p in auxiliary_dataset.columns for p in proxies_col)
        assert protected_class_col in auxiliary_dataset.columns

        self.primary_dataset = primary_dataset
        self.auxiliary_dataset = auxiliary_dataset
        self.primary_ground_truth_col = primary_ground_truth_col
        self.primary_features_col = primary_features_col
        self.protected_class_col = protected_class_col
        self.proxies = proxies_col
        self.prediction_col = prediction_col
        self.protected_class_names = self.primary_dataset[protected_class_col].unique()
        self.protected_class_names.sort()
        self.combined = pd.concat([self.primary_dataset, self.auxiliary_dataset]).reset_index()

        self.Y = self.combined[self.primary_ground_truth_col]
        self.Yhat = self.combined[self.prediction_col]
        self.primary_index = pd.Series([True] * len(self.primary_dataset) + [False] * len(self.auxiliary_dataset))
        (self.Y_from_proxies, self.model_prediction_from_proxies,
         self.protected_class_membership, self.protected_class_prob) = self.build_estimators_from_proxies()


        self.quadrant_dict = self.generate_binary_classification_quadrants()
        self.hemisphere_readings = self.generate_hemisphere_statistics_by_protected_class()
        self.quadrant_readings = self.generate_quadrant_statistics_by_protected_class()
        self.tpr_tnr, self.ppv_npv = self.generate_tpr_tnr_ppv_npv_by_protected_class()

    def generate_binary_classification_quadrants(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        TT = ((self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        TF = ((self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        FT = ((1 - self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        FF = ((1 - self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        return {
            (NEGATIVE, NEGATIVE): FF,
            (NEGATIVE, POSITIVE): FT,
            (POSITIVE, NEGATIVE): TF,
            (POSITIVE, POSITIVE): TT,
        }

    def generate_hemisphere_statistics_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
        hemisphere_component_tuples= list(
            itertools.product(
                self.protected_class_names,
                bounds,
                [NEGATIVE, POSITIVE],
                [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS],
                [GROUND_TRUTH, MODEL_PREDICTION]
            )
        )
        return {c: self.partial_identification_hemisphere_bounds_for_protected_class(*c)
                                 for c in hemisphere_component_tuples}

    def generate_quadrant_statistics_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
        quadrant_component_tuples = list(
            itertools.product(
                self.protected_class_names, bounds, [NEGATIVE, POSITIVE], [NEGATIVE, POSITIVE],
                [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
            )
        )

        return {c: self.partial_identification_quadrant_bounds_for_protected_class(*c)
                               for c in quadrant_component_tuples}


    def generate_tpr_tnr_ppv_npv_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        tpr_tnr = {}
        ppv_npv = {}
        component_tuples = list(
            itertools.product(
                self.protected_class_names, [LOWER_BOUND, UPPER_BOUND, EXPECTATION], [NEGATIVE, POSITIVE],
                [NEGATIVE, POSITIVE], [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
            )
        )
        for component_tuple in component_tuples:
            selected_protected_class, bound, truth, pred, in_class = component_tuple
            if bound == LOWER_BOUND:  # see (38) of https://arxiv.org/pdf/1906.00285.pdf
                num_start = LOWER_BOUND
                denom_start = LOWER_BOUND
                denom_end = UPPER_BOUND

            elif bound == UPPER_BOUND:
                num_start = UPPER_BOUND
                denom_start = UPPER_BOUND
                denom_end = LOWER_BOUND

            elif bound == EXPECTATION:
                num_start = EXPECTATION
                denom_start = EXPECTATION
                denom_end = EXPECTATION

            ############TPRD_TPND_CALCULATION#############

            numerator = truncate(
                self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
            denominator = (truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                           + truncate(
                        self.quadrant_readings[selected_protected_class, denom_end, truth, 1 - pred, in_class]))

            if denominator == 0:
                tpr_tnr[component_tuple] = 1
            else:
                tpr_tnr[component_tuple] = numerator / denominator

            ############PPVD_NPVD_CALCULATION#############

            numerator = truncate(
                self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
            denominator = (
                    truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                    + truncate(self.quadrant_readings[selected_protected_class, denom_end, 1 - truth, pred, in_class]))

            if denominator == 0:
                ppv_npv[component_tuple] = 1
            else:
                ppv_npv[component_tuple] = numerator / denominator

        return tpr_tnr, ppv_npv

    def partial_identification_quadrant_bounds_for_protected_class(self, protected_class_name, bound, truth, predicted, in_class=IN_PROTECTED_CLASS):
        &#34;&#34;&#34;

        :param protected_class_name:
        :type protected_class_name:
        :param bound:
        :type bound:
        :param truth:
        :type truth:
        :param predicted:
        :type predicted:
        :param in_class:
        :type in_class:
        :return:
        :rtype:
        &#34;&#34;&#34;
        if bound == LOWER_BOUND:
            f = compute_lower_bound
        elif bound == UPPER_BOUND:
            f = compute_upper_bound
        elif bound == EXPECTATION:
            f = compute_expected_outcome
        if in_class:
            partial_identification_input = {
                &#39;primary_index&#39;: self.primary_index,
                &#39;protected_class_prediction_from_proxies&#39;:self.protected_class_prob[protected_class_name],
                &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
                &#39;protected_class_status&#39;:self.protected_class_membership[protected_class_name],
                &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
            }
        else:
            partial_identification_input = {
                &#39;primary_index&#39;: self.primary_index,
                &#39;protected_class_prediction_from_proxies&#39;:1  - self.protected_class_prob[protected_class_name],
                &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
                &#39;protected_class_status&#39;:1 - self.protected_class_membership[protected_class_name],
                &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
            }
        return f(partial_identification_input[&#39;primary_index&#39;],
                 partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;protected_class_status&#39;],
                 partial_identification_input[&#39;predicted_outcome&#39;],
                 )

    def partial_identification_hemisphere_bounds_for_protected_class(self, protected_class_name, bound, truth_or_prediction, in_class=IN_PROTECTED_CLASS,
                                 target=&#39;prediction&#39;):
        &#34;&#34;&#34;

        :param protected_class_name:
        :type protected_class_name:
        :param bound:
        :type bound:
        :param truth_or_prediction:
        :type truth_or_prediction:
        :param in_class:
        :type in_class:
        :param target:
        :type target:
        :return:
        :rtype:
        &#34;&#34;&#34;
        if bound == LOWER_BOUND:
            f = compute_lower_bound
        elif bound == UPPER_BOUND:
            f = compute_upper_bound
        elif bound == EXPECTATION:
            f = compute_expected_outcome

        partial_identification_input = {&#39;primary_index&#39;: self.primary_index,
                                        &#39;protected_class_prediction_from_proxies&#39;: None,
                                        &#39;outcome_prediction_from_proxies&#39;: None,
                                        &#39;protected_class_status&#39;: None,
                                        &#39;predicted_outcome&#39;: None}
        if target == &#39;prediction&#39;:
            partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                        self.model_prediction_from_proxies == truth_or_prediction).astype(int)
            partial_identification_input[&#39;predicted_outcome&#39;] = (self.Yhat == truth_or_prediction).astype(int)
        else:
            partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                        self.Y_from_proxies == truth_or_prediction).astype(int)
            partial_identification_input[&#39;predicted_outcome&#39;] = (self.Y == truth_or_prediction).astype(int)

        if in_class:
            partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                        self.protected_class_prob[protected_class_name]).astype(int)
            partial_identification_input[&#39;protected_class_status&#39;] = (
                        self.protected_class_membership[protected_class_name]).astype(int)
        else:
            partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                        1 - self.protected_class_prob[protected_class_name]).astype(int)
            partial_identification_input[&#39;protected_class_status&#39;] = (
                        1 - self.protected_class_membership[protected_class_name]).astype(int)

        return f(partial_identification_input[&#39;primary_index&#39;],
                 partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;protected_class_status&#39;],
                 partial_identification_input[&#39;predicted_outcome&#39;],
                 )

    def build_estimators_from_proxies(
            self, n_k=5, estimator=RandomForestClassifier):
        &#34;&#34;&#34;

        :param n_k:
        :type n_k:
        :param estimator:
        :type estimator:
        :return:
        :rtype:
        &#34;&#34;&#34;

        &#34;&#34;&#34;1. Divide Primary and Auxiliary datasets into K subsets&#34;&#34;&#34;

        K_pri, K_aux = np.array_split(self.primary_dataset, n_k), \
                       np.array_split(self.auxiliary_dataset, n_k)

        &#34;&#34;&#34;2. Define models to learn the ground truth, model&#39;s prediction, and protected class status
         from proxies.
        Recall that the ground truth and model&#39;s predicion are only available for the primary set,
        and protected class status is only available for the auxiliary set&#34;&#34;&#34;
        rfcs_y_pri = [estimator() for idx in range(n_k)]
        rfcs_yhat_pri = [estimator() for idx in range(n_k)]
        rfcs_protected_class_sec = [estimator() for idx in range(n_k)]

        &#34;&#34;&#34;3. Train K models for each of the K subsets&#34;&#34;&#34;
        for idx in range(n_k):  # train k models on each of k sets
            rfcs_y_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.primary_ground_truth_col])
            rfcs_yhat_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.prediction_col])
            rfcs_protected_class_sec[idx].fit(K_aux[idx][self.proxies], K_aux[idx][self.protected_class_col])

        &#34;&#34;&#34;4. Use all ~k models to infer ground truth, model&#39;s prediction, and protected class status on the kth set.&#34;&#34;&#34;
        for idx in range(n_k):
            range_excluding_idx = [n for n in range(n_k) if n != idx]
            K_pri[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
                [rfcs_y_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_aux[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
                [rfcs_y_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_pri[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
                [rfcs_yhat_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_aux[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
                [rfcs_yhat_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_pri[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
                [rfcs_protected_class_sec[notk_idx].predict_proba(K_pri[idx][self.proxies]) for notk_idx in
                 range_excluding_idx]).mean(axis=0).tolist()
            K_aux[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
                [rfcs_protected_class_sec[notk_idx].predict_proba(K_aux[idx][self.proxies]) for notk_idx in
                 range_excluding_idx]).mean(axis=0).tolist()

        &#34;&#34;&#34;5. recombine k subsets into a combined set&#34;&#34;&#34;
        combined = pd.concat(K_pri + K_aux).reset_index()

        &#34;&#34;&#34;6a. record proxy model&#39;s prediction of ground truth.&#34;&#34;&#34;
        Y_from_proxies = combined[GROUND_TRUTH_FROM_PROXIES].round(0)

        &#34;&#34;&#34;6b. record proxy model&#39;s prediction of model&#39;s prediction.&#34;&#34;&#34;
        model_prediction_from_proxies = combined[MODEL_PREDICTION_FROM_PROXIES].round(0)


        &#34;&#34;&#34;6c. record model-based prediction of protected class membership for each protected class&#34;&#34;&#34;
        protected_class_prob = {}
        for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
            protected_class_prob[protected_class] = \
                combined[PROTECTED_CLASS_FROM_PROXIES].apply(lambda x: x[idx]).reset_index()[
                    PROTECTED_CLASS_FROM_PROXIES].round(0)

        &#34;&#34;&#34;6d. record actual protected class membership for each protected class.&#34;&#34;&#34;
        protected_class_membership = {}
        for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
            protected_class_membership[protected_class] = np.hstack([
                np.empty(shape=len(self.primary_dataset),),
                (self.auxiliary_dataset[self.protected_class_col] == protected_class).values])

        return Y_from_proxies, model_prediction_from_proxies, protected_class_membership, protected_class_prob


    def positive_or_negative_hemisphere_reading(self, protected_class, result=POSITIVE, variable=MODEL_PREDICTION,
                          within_protected_class=True):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.positive_or_negative_hemisphere_reading(self.hemisphere_readings, protected_class, result, variable,
                                                               within_protected_class)))

    def confusion_matrix_quadrant_reading(self, protected_class, truth=POSITIVE, prediction=POSITIVE,
                        within_protected_class=True):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
            metrics.confusion_matrix_quadrant_reading(self.hemisphere_readings, protected_class, truth, prediction,
                                                         within_protected_class)))

    def tpr_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict((zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tpr_reading(self.tpr_tnr, protected_class))))

    def tnr_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tnr_reading(self.tpr_tnr, protected_class)))

    def npv_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip(&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;,
                        metrics.npv_reading(self.ppv_npv, protected_class)))

    def ppv_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.ppv_reading(self.ppv_npv, protected_class)))

    def positive_or_negative_hemisphere_disparity(self, protected_class, comparison_class=OTHERS, variable=MODEL_PREDICTION, value=POSITIVE):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.positive_or_negative_hemisphere_disparity(self.hemisphere_readings,protected_class, comparison_class, variable, value)))

    def confusion_matrix_quadrant_disparity(self, protected_class, truth=POSITIVE, prediction=POSITIVE, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.confusion_matrix_quadrant_disparity(self.quadrant_readings,protected_class, truth, prediction, comparison_class)))

    def tpr_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tpr_disparity(self.tpr_tnr, protected_class, comparison_class)))

    def tnr_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tnr_disparity(self.tpr_tnr, protected_class, comparison_class)))

    def ppv_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.ppv_disparity(self.ppv_npv, protected_class, comparison_class)))

    def npv_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                   metrics.npv_disparity(self.ppv_npv, protected_class, comparison_class)))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fairness.PartialIdentification.PartialIdentification"><code class="flex name class">
<span>class <span class="ident">PartialIdentification</span></span>
<span>(</span><span>primary_dataset, auxiliary_dataset, primary_ground_truth_col, primary_features_col, protected_class_col, prediction_col, proxies_col)</span>
</code></dt>
<dd>
<div class="desc"><p>:param primary_dataset:
:type primary_dataset:
:param auxiliary_dataset:
:type auxiliary_dataset:
:param primary_ground_truth_col:
:type primary_ground_truth_col:
:param primary_features_col:
:type primary_features_col:
:param protected_class_col:
:type protected_class_col:
:param prediction_col:
:type prediction_col:
:param proxies_col:
:type proxies_col:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartialIdentification:
    def __init__(
            self,
            primary_dataset,
            auxiliary_dataset,
            primary_ground_truth_col,
            primary_features_col,
            protected_class_col,
            prediction_col,
            proxies_col,
    ):
        &#34;&#34;&#34;

        :param primary_dataset:
        :type primary_dataset:
        :param auxiliary_dataset:
        :type auxiliary_dataset:
        :param primary_ground_truth_col:
        :type primary_ground_truth_col:
        :param primary_features_col:
        :type primary_features_col:
        :param protected_class_col:
        :type protected_class_col:
        :param prediction_col:
        :type prediction_col:
        :param proxies_col:
        :type proxies_col:
        &#34;&#34;&#34;
        assert primary_ground_truth_col in primary_dataset.columns
        assert all(f in primary_dataset.columns for f in primary_features_col)
        assert all(p in primary_dataset.columns for p in proxies_col)
        assert all(p in auxiliary_dataset.columns for p in proxies_col)
        assert protected_class_col in auxiliary_dataset.columns

        self.primary_dataset = primary_dataset
        self.auxiliary_dataset = auxiliary_dataset
        self.primary_ground_truth_col = primary_ground_truth_col
        self.primary_features_col = primary_features_col
        self.protected_class_col = protected_class_col
        self.proxies = proxies_col
        self.prediction_col = prediction_col
        self.protected_class_names = self.primary_dataset[protected_class_col].unique()
        self.protected_class_names.sort()
        self.combined = pd.concat([self.primary_dataset, self.auxiliary_dataset]).reset_index()

        self.Y = self.combined[self.primary_ground_truth_col]
        self.Yhat = self.combined[self.prediction_col]
        self.primary_index = pd.Series([True] * len(self.primary_dataset) + [False] * len(self.auxiliary_dataset))
        (self.Y_from_proxies, self.model_prediction_from_proxies,
         self.protected_class_membership, self.protected_class_prob) = self.build_estimators_from_proxies()


        self.quadrant_dict = self.generate_binary_classification_quadrants()
        self.hemisphere_readings = self.generate_hemisphere_statistics_by_protected_class()
        self.quadrant_readings = self.generate_quadrant_statistics_by_protected_class()
        self.tpr_tnr, self.ppv_npv = self.generate_tpr_tnr_ppv_npv_by_protected_class()

    def generate_binary_classification_quadrants(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        TT = ((self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        TF = ((self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        FT = ((1 - self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        FF = ((1 - self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
              ).astype(int)
        return {
            (NEGATIVE, NEGATIVE): FF,
            (NEGATIVE, POSITIVE): FT,
            (POSITIVE, NEGATIVE): TF,
            (POSITIVE, POSITIVE): TT,
        }

    def generate_hemisphere_statistics_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
        hemisphere_component_tuples= list(
            itertools.product(
                self.protected_class_names,
                bounds,
                [NEGATIVE, POSITIVE],
                [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS],
                [GROUND_TRUTH, MODEL_PREDICTION]
            )
        )
        return {c: self.partial_identification_hemisphere_bounds_for_protected_class(*c)
                                 for c in hemisphere_component_tuples}

    def generate_quadrant_statistics_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
        quadrant_component_tuples = list(
            itertools.product(
                self.protected_class_names, bounds, [NEGATIVE, POSITIVE], [NEGATIVE, POSITIVE],
                [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
            )
        )

        return {c: self.partial_identification_quadrant_bounds_for_protected_class(*c)
                               for c in quadrant_component_tuples}


    def generate_tpr_tnr_ppv_npv_by_protected_class(self):
        &#34;&#34;&#34;

        :return:
        :rtype:
        &#34;&#34;&#34;
        tpr_tnr = {}
        ppv_npv = {}
        component_tuples = list(
            itertools.product(
                self.protected_class_names, [LOWER_BOUND, UPPER_BOUND, EXPECTATION], [NEGATIVE, POSITIVE],
                [NEGATIVE, POSITIVE], [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
            )
        )
        for component_tuple in component_tuples:
            selected_protected_class, bound, truth, pred, in_class = component_tuple
            if bound == LOWER_BOUND:  # see (38) of https://arxiv.org/pdf/1906.00285.pdf
                num_start = LOWER_BOUND
                denom_start = LOWER_BOUND
                denom_end = UPPER_BOUND

            elif bound == UPPER_BOUND:
                num_start = UPPER_BOUND
                denom_start = UPPER_BOUND
                denom_end = LOWER_BOUND

            elif bound == EXPECTATION:
                num_start = EXPECTATION
                denom_start = EXPECTATION
                denom_end = EXPECTATION

            ############TPRD_TPND_CALCULATION#############

            numerator = truncate(
                self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
            denominator = (truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                           + truncate(
                        self.quadrant_readings[selected_protected_class, denom_end, truth, 1 - pred, in_class]))

            if denominator == 0:
                tpr_tnr[component_tuple] = 1
            else:
                tpr_tnr[component_tuple] = numerator / denominator

            ############PPVD_NPVD_CALCULATION#############

            numerator = truncate(
                self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
            denominator = (
                    truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                    + truncate(self.quadrant_readings[selected_protected_class, denom_end, 1 - truth, pred, in_class]))

            if denominator == 0:
                ppv_npv[component_tuple] = 1
            else:
                ppv_npv[component_tuple] = numerator / denominator

        return tpr_tnr, ppv_npv

    def partial_identification_quadrant_bounds_for_protected_class(self, protected_class_name, bound, truth, predicted, in_class=IN_PROTECTED_CLASS):
        &#34;&#34;&#34;

        :param protected_class_name:
        :type protected_class_name:
        :param bound:
        :type bound:
        :param truth:
        :type truth:
        :param predicted:
        :type predicted:
        :param in_class:
        :type in_class:
        :return:
        :rtype:
        &#34;&#34;&#34;
        if bound == LOWER_BOUND:
            f = compute_lower_bound
        elif bound == UPPER_BOUND:
            f = compute_upper_bound
        elif bound == EXPECTATION:
            f = compute_expected_outcome
        if in_class:
            partial_identification_input = {
                &#39;primary_index&#39;: self.primary_index,
                &#39;protected_class_prediction_from_proxies&#39;:self.protected_class_prob[protected_class_name],
                &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
                &#39;protected_class_status&#39;:self.protected_class_membership[protected_class_name],
                &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
            }
        else:
            partial_identification_input = {
                &#39;primary_index&#39;: self.primary_index,
                &#39;protected_class_prediction_from_proxies&#39;:1  - self.protected_class_prob[protected_class_name],
                &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
                &#39;protected_class_status&#39;:1 - self.protected_class_membership[protected_class_name],
                &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
            }
        return f(partial_identification_input[&#39;primary_index&#39;],
                 partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;protected_class_status&#39;],
                 partial_identification_input[&#39;predicted_outcome&#39;],
                 )

    def partial_identification_hemisphere_bounds_for_protected_class(self, protected_class_name, bound, truth_or_prediction, in_class=IN_PROTECTED_CLASS,
                                 target=&#39;prediction&#39;):
        &#34;&#34;&#34;

        :param protected_class_name:
        :type protected_class_name:
        :param bound:
        :type bound:
        :param truth_or_prediction:
        :type truth_or_prediction:
        :param in_class:
        :type in_class:
        :param target:
        :type target:
        :return:
        :rtype:
        &#34;&#34;&#34;
        if bound == LOWER_BOUND:
            f = compute_lower_bound
        elif bound == UPPER_BOUND:
            f = compute_upper_bound
        elif bound == EXPECTATION:
            f = compute_expected_outcome

        partial_identification_input = {&#39;primary_index&#39;: self.primary_index,
                                        &#39;protected_class_prediction_from_proxies&#39;: None,
                                        &#39;outcome_prediction_from_proxies&#39;: None,
                                        &#39;protected_class_status&#39;: None,
                                        &#39;predicted_outcome&#39;: None}
        if target == &#39;prediction&#39;:
            partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                        self.model_prediction_from_proxies == truth_or_prediction).astype(int)
            partial_identification_input[&#39;predicted_outcome&#39;] = (self.Yhat == truth_or_prediction).astype(int)
        else:
            partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                        self.Y_from_proxies == truth_or_prediction).astype(int)
            partial_identification_input[&#39;predicted_outcome&#39;] = (self.Y == truth_or_prediction).astype(int)

        if in_class:
            partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                        self.protected_class_prob[protected_class_name]).astype(int)
            partial_identification_input[&#39;protected_class_status&#39;] = (
                        self.protected_class_membership[protected_class_name]).astype(int)
        else:
            partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                        1 - self.protected_class_prob[protected_class_name]).astype(int)
            partial_identification_input[&#39;protected_class_status&#39;] = (
                        1 - self.protected_class_membership[protected_class_name]).astype(int)

        return f(partial_identification_input[&#39;primary_index&#39;],
                 partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
                 partial_identification_input[&#39;protected_class_status&#39;],
                 partial_identification_input[&#39;predicted_outcome&#39;],
                 )

    def build_estimators_from_proxies(
            self, n_k=5, estimator=RandomForestClassifier):
        &#34;&#34;&#34;

        :param n_k:
        :type n_k:
        :param estimator:
        :type estimator:
        :return:
        :rtype:
        &#34;&#34;&#34;

        &#34;&#34;&#34;1. Divide Primary and Auxiliary datasets into K subsets&#34;&#34;&#34;

        K_pri, K_aux = np.array_split(self.primary_dataset, n_k), \
                       np.array_split(self.auxiliary_dataset, n_k)

        &#34;&#34;&#34;2. Define models to learn the ground truth, model&#39;s prediction, and protected class status
         from proxies.
        Recall that the ground truth and model&#39;s predicion are only available for the primary set,
        and protected class status is only available for the auxiliary set&#34;&#34;&#34;
        rfcs_y_pri = [estimator() for idx in range(n_k)]
        rfcs_yhat_pri = [estimator() for idx in range(n_k)]
        rfcs_protected_class_sec = [estimator() for idx in range(n_k)]

        &#34;&#34;&#34;3. Train K models for each of the K subsets&#34;&#34;&#34;
        for idx in range(n_k):  # train k models on each of k sets
            rfcs_y_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.primary_ground_truth_col])
            rfcs_yhat_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.prediction_col])
            rfcs_protected_class_sec[idx].fit(K_aux[idx][self.proxies], K_aux[idx][self.protected_class_col])

        &#34;&#34;&#34;4. Use all ~k models to infer ground truth, model&#39;s prediction, and protected class status on the kth set.&#34;&#34;&#34;
        for idx in range(n_k):
            range_excluding_idx = [n for n in range(n_k) if n != idx]
            K_pri[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
                [rfcs_y_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_aux[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
                [rfcs_y_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_pri[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
                [rfcs_yhat_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_aux[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
                [rfcs_yhat_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
                 range_excluding_idx]).mean(axis=0)
            K_pri[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
                [rfcs_protected_class_sec[notk_idx].predict_proba(K_pri[idx][self.proxies]) for notk_idx in
                 range_excluding_idx]).mean(axis=0).tolist()
            K_aux[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
                [rfcs_protected_class_sec[notk_idx].predict_proba(K_aux[idx][self.proxies]) for notk_idx in
                 range_excluding_idx]).mean(axis=0).tolist()

        &#34;&#34;&#34;5. recombine k subsets into a combined set&#34;&#34;&#34;
        combined = pd.concat(K_pri + K_aux).reset_index()

        &#34;&#34;&#34;6a. record proxy model&#39;s prediction of ground truth.&#34;&#34;&#34;
        Y_from_proxies = combined[GROUND_TRUTH_FROM_PROXIES].round(0)

        &#34;&#34;&#34;6b. record proxy model&#39;s prediction of model&#39;s prediction.&#34;&#34;&#34;
        model_prediction_from_proxies = combined[MODEL_PREDICTION_FROM_PROXIES].round(0)


        &#34;&#34;&#34;6c. record model-based prediction of protected class membership for each protected class&#34;&#34;&#34;
        protected_class_prob = {}
        for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
            protected_class_prob[protected_class] = \
                combined[PROTECTED_CLASS_FROM_PROXIES].apply(lambda x: x[idx]).reset_index()[
                    PROTECTED_CLASS_FROM_PROXIES].round(0)

        &#34;&#34;&#34;6d. record actual protected class membership for each protected class.&#34;&#34;&#34;
        protected_class_membership = {}
        for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
            protected_class_membership[protected_class] = np.hstack([
                np.empty(shape=len(self.primary_dataset),),
                (self.auxiliary_dataset[self.protected_class_col] == protected_class).values])

        return Y_from_proxies, model_prediction_from_proxies, protected_class_membership, protected_class_prob


    def positive_or_negative_hemisphere_reading(self, protected_class, result=POSITIVE, variable=MODEL_PREDICTION,
                          within_protected_class=True):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.positive_or_negative_hemisphere_reading(self.hemisphere_readings, protected_class, result, variable,
                                                               within_protected_class)))

    def confusion_matrix_quadrant_reading(self, protected_class, truth=POSITIVE, prediction=POSITIVE,
                        within_protected_class=True):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
            metrics.confusion_matrix_quadrant_reading(self.hemisphere_readings, protected_class, truth, prediction,
                                                         within_protected_class)))

    def tpr_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict((zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tpr_reading(self.tpr_tnr, protected_class))))

    def tnr_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tnr_reading(self.tpr_tnr, protected_class)))

    def npv_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip(&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;,
                        metrics.npv_reading(self.ppv_npv, protected_class)))

    def ppv_reading(self, protected_class):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.ppv_reading(self.ppv_npv, protected_class)))

    def positive_or_negative_hemisphere_disparity(self, protected_class, comparison_class=OTHERS, variable=MODEL_PREDICTION, value=POSITIVE):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.positive_or_negative_hemisphere_disparity(self.hemisphere_readings,protected_class, comparison_class, variable, value)))

    def confusion_matrix_quadrant_disparity(self, protected_class, truth=POSITIVE, prediction=POSITIVE, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.confusion_matrix_quadrant_disparity(self.quadrant_readings,protected_class, truth, prediction, comparison_class)))

    def tpr_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tpr_disparity(self.tpr_tnr, protected_class, comparison_class)))

    def tnr_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.tnr_disparity(self.tpr_tnr, protected_class, comparison_class)))

    def ppv_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                        metrics.ppv_disparity(self.ppv_npv, protected_class, comparison_class)))

    def npv_disparity(self, protected_class, comparison_class=OTHERS):
        &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
        return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                   metrics.npv_disparity(self.ppv_npv, protected_class, comparison_class)))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fairness.PartialIdentification.PartialIdentification.build_estimators_from_proxies"><code class="name flex">
<span>def <span class="ident">build_estimators_from_proxies</span></span>(<span>self, n_k=5, estimator=sklearn.ensemble._forest.RandomForestClassifier)</span>
</code></dt>
<dd>
<div class="desc"><p>:param n_k:
:type n_k:
:param estimator:
:type estimator:
:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_estimators_from_proxies(
        self, n_k=5, estimator=RandomForestClassifier):
    &#34;&#34;&#34;

    :param n_k:
    :type n_k:
    :param estimator:
    :type estimator:
    :return:
    :rtype:
    &#34;&#34;&#34;

    &#34;&#34;&#34;1. Divide Primary and Auxiliary datasets into K subsets&#34;&#34;&#34;

    K_pri, K_aux = np.array_split(self.primary_dataset, n_k), \
                   np.array_split(self.auxiliary_dataset, n_k)

    &#34;&#34;&#34;2. Define models to learn the ground truth, model&#39;s prediction, and protected class status
     from proxies.
    Recall that the ground truth and model&#39;s predicion are only available for the primary set,
    and protected class status is only available for the auxiliary set&#34;&#34;&#34;
    rfcs_y_pri = [estimator() for idx in range(n_k)]
    rfcs_yhat_pri = [estimator() for idx in range(n_k)]
    rfcs_protected_class_sec = [estimator() for idx in range(n_k)]

    &#34;&#34;&#34;3. Train K models for each of the K subsets&#34;&#34;&#34;
    for idx in range(n_k):  # train k models on each of k sets
        rfcs_y_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.primary_ground_truth_col])
        rfcs_yhat_pri[idx].fit(K_pri[idx][self.proxies], K_pri[idx][self.prediction_col])
        rfcs_protected_class_sec[idx].fit(K_aux[idx][self.proxies], K_aux[idx][self.protected_class_col])

    &#34;&#34;&#34;4. Use all ~k models to infer ground truth, model&#39;s prediction, and protected class status on the kth set.&#34;&#34;&#34;
    for idx in range(n_k):
        range_excluding_idx = [n for n in range(n_k) if n != idx]
        K_pri[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
            [rfcs_y_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
             range_excluding_idx]).mean(axis=0)
        K_aux[idx][GROUND_TRUTH_FROM_PROXIES] = np.asarray(
            [rfcs_y_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
             range_excluding_idx]).mean(axis=0)
        K_pri[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
            [rfcs_yhat_pri[notk_idx].predict_proba(K_pri[idx][self.proxies])[:, 1] for notk_idx in
             range_excluding_idx]).mean(axis=0)
        K_aux[idx][MODEL_PREDICTION_FROM_PROXIES] = np.asarray(
            [rfcs_yhat_pri[notk_idx].predict_proba(K_aux[idx][self.proxies])[:, 1] for notk_idx in
             range_excluding_idx]).mean(axis=0)
        K_pri[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
            [rfcs_protected_class_sec[notk_idx].predict_proba(K_pri[idx][self.proxies]) for notk_idx in
             range_excluding_idx]).mean(axis=0).tolist()
        K_aux[idx][PROTECTED_CLASS_FROM_PROXIES] = np.asarray(
            [rfcs_protected_class_sec[notk_idx].predict_proba(K_aux[idx][self.proxies]) for notk_idx in
             range_excluding_idx]).mean(axis=0).tolist()

    &#34;&#34;&#34;5. recombine k subsets into a combined set&#34;&#34;&#34;
    combined = pd.concat(K_pri + K_aux).reset_index()

    &#34;&#34;&#34;6a. record proxy model&#39;s prediction of ground truth.&#34;&#34;&#34;
    Y_from_proxies = combined[GROUND_TRUTH_FROM_PROXIES].round(0)

    &#34;&#34;&#34;6b. record proxy model&#39;s prediction of model&#39;s prediction.&#34;&#34;&#34;
    model_prediction_from_proxies = combined[MODEL_PREDICTION_FROM_PROXIES].round(0)


    &#34;&#34;&#34;6c. record model-based prediction of protected class membership for each protected class&#34;&#34;&#34;
    protected_class_prob = {}
    for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
        protected_class_prob[protected_class] = \
            combined[PROTECTED_CLASS_FROM_PROXIES].apply(lambda x: x[idx]).reset_index()[
                PROTECTED_CLASS_FROM_PROXIES].round(0)

    &#34;&#34;&#34;6d. record actual protected class membership for each protected class.&#34;&#34;&#34;
    protected_class_membership = {}
    for idx, protected_class in enumerate(rfcs_protected_class_sec[0].classes_):
        protected_class_membership[protected_class] = np.hstack([
            np.empty(shape=len(self.primary_dataset),),
            (self.auxiliary_dataset[self.protected_class_col] == protected_class).values])

    return Y_from_proxies, model_prediction_from_proxies, protected_class_membership, protected_class_prob</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_disparity"><code class="name flex">
<span>def <span class="ident">confusion_matrix_quadrant_disparity</span></span>(<span>self, protected_class, truth=1, prediction=1, comparison_class='others')</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def confusion_matrix_quadrant_disparity(self, protected_class, truth=POSITIVE, prediction=POSITIVE, comparison_class=OTHERS):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.confusion_matrix_quadrant_disparity(self.quadrant_readings,protected_class, truth, prediction, comparison_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_reading"><code class="name flex">
<span>def <span class="ident">confusion_matrix_quadrant_reading</span></span>(<span>self, protected_class, truth=1, prediction=1, within_protected_class=True)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def confusion_matrix_quadrant_reading(self, protected_class, truth=POSITIVE, prediction=POSITIVE,
                    within_protected_class=True):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
        metrics.confusion_matrix_quadrant_reading(self.hemisphere_readings, protected_class, truth, prediction,
                                                     within_protected_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.generate_binary_classification_quadrants"><code class="name flex">
<span>def <span class="ident">generate_binary_classification_quadrants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_binary_classification_quadrants(self):
    &#34;&#34;&#34;

    :return:
    :rtype:
    &#34;&#34;&#34;
    TT = ((self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
          ).astype(int)
    TF = ((self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
          ).astype(int)
    FT = ((1 - self.Y_from_proxies).astype(bool) &amp; (self.model_prediction_from_proxies).astype(bool)
          ).astype(int)
    FF = ((1 - self.Y_from_proxies).astype(bool) &amp; (1 - self.model_prediction_from_proxies).astype(bool)
          ).astype(int)
    return {
        (NEGATIVE, NEGATIVE): FF,
        (NEGATIVE, POSITIVE): FT,
        (POSITIVE, NEGATIVE): TF,
        (POSITIVE, POSITIVE): TT,
    }</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.generate_hemisphere_statistics_by_protected_class"><code class="name flex">
<span>def <span class="ident">generate_hemisphere_statistics_by_protected_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_hemisphere_statistics_by_protected_class(self):
    &#34;&#34;&#34;

    :return:
    :rtype:
    &#34;&#34;&#34;
    bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
    hemisphere_component_tuples= list(
        itertools.product(
            self.protected_class_names,
            bounds,
            [NEGATIVE, POSITIVE],
            [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS],
            [GROUND_TRUTH, MODEL_PREDICTION]
        )
    )
    return {c: self.partial_identification_hemisphere_bounds_for_protected_class(*c)
                             for c in hemisphere_component_tuples}</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.generate_quadrant_statistics_by_protected_class"><code class="name flex">
<span>def <span class="ident">generate_quadrant_statistics_by_protected_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_quadrant_statistics_by_protected_class(self):
    &#34;&#34;&#34;

    :return:
    :rtype:
    &#34;&#34;&#34;
    bounds = [LOWER_BOUND, UPPER_BOUND, EXPECTATION]
    quadrant_component_tuples = list(
        itertools.product(
            self.protected_class_names, bounds, [NEGATIVE, POSITIVE], [NEGATIVE, POSITIVE],
            [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
        )
    )

    return {c: self.partial_identification_quadrant_bounds_for_protected_class(*c)
                           for c in quadrant_component_tuples}</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.generate_tpr_tnr_ppv_npv_by_protected_class"><code class="name flex">
<span>def <span class="ident">generate_tpr_tnr_ppv_npv_by_protected_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_tpr_tnr_ppv_npv_by_protected_class(self):
    &#34;&#34;&#34;

    :return:
    :rtype:
    &#34;&#34;&#34;
    tpr_tnr = {}
    ppv_npv = {}
    component_tuples = list(
        itertools.product(
            self.protected_class_names, [LOWER_BOUND, UPPER_BOUND, EXPECTATION], [NEGATIVE, POSITIVE],
            [NEGATIVE, POSITIVE], [IN_PROTECTED_CLASS, NOT_IN_PROTECTED_CLASS]
        )
    )
    for component_tuple in component_tuples:
        selected_protected_class, bound, truth, pred, in_class = component_tuple
        if bound == LOWER_BOUND:  # see (38) of https://arxiv.org/pdf/1906.00285.pdf
            num_start = LOWER_BOUND
            denom_start = LOWER_BOUND
            denom_end = UPPER_BOUND

        elif bound == UPPER_BOUND:
            num_start = UPPER_BOUND
            denom_start = UPPER_BOUND
            denom_end = LOWER_BOUND

        elif bound == EXPECTATION:
            num_start = EXPECTATION
            denom_start = EXPECTATION
            denom_end = EXPECTATION

        ############TPRD_TPND_CALCULATION#############

        numerator = truncate(
            self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
        denominator = (truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                       + truncate(
                    self.quadrant_readings[selected_protected_class, denom_end, truth, 1 - pred, in_class]))

        if denominator == 0:
            tpr_tnr[component_tuple] = 1
        else:
            tpr_tnr[component_tuple] = numerator / denominator

        ############PPVD_NPVD_CALCULATION#############

        numerator = truncate(
            self.quadrant_readings[selected_protected_class, num_start, truth, pred, in_class])
        denominator = (
                truncate(self.quadrant_readings[selected_protected_class, denom_start, truth, pred, in_class])
                + truncate(self.quadrant_readings[selected_protected_class, denom_end, 1 - truth, pred, in_class]))

        if denominator == 0:
            ppv_npv[component_tuple] = 1
        else:
            ppv_npv[component_tuple] = numerator / denominator

    return tpr_tnr, ppv_npv</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.npv_disparity"><code class="name flex">
<span>def <span class="ident">npv_disparity</span></span>(<span>self, protected_class, comparison_class='others')</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def npv_disparity(self, protected_class, comparison_class=OTHERS):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
               metrics.npv_disparity(self.ppv_npv, protected_class, comparison_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.npv_reading"><code class="name flex">
<span>def <span class="ident">npv_reading</span></span>(<span>self, protected_class)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def npv_reading(self, protected_class):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip(&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;,
                    metrics.npv_reading(self.ppv_npv, protected_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.partial_identification_hemisphere_bounds_for_protected_class"><code class="name flex">
<span>def <span class="ident">partial_identification_hemisphere_bounds_for_protected_class</span></span>(<span>self, protected_class_name, bound, truth_or_prediction, in_class=True, target='prediction')</span>
</code></dt>
<dd>
<div class="desc"><p>:param protected_class_name:
:type protected_class_name:
:param bound:
:type bound:
:param truth_or_prediction:
:type truth_or_prediction:
:param in_class:
:type in_class:
:param target:
:type target:
:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial_identification_hemisphere_bounds_for_protected_class(self, protected_class_name, bound, truth_or_prediction, in_class=IN_PROTECTED_CLASS,
                             target=&#39;prediction&#39;):
    &#34;&#34;&#34;

    :param protected_class_name:
    :type protected_class_name:
    :param bound:
    :type bound:
    :param truth_or_prediction:
    :type truth_or_prediction:
    :param in_class:
    :type in_class:
    :param target:
    :type target:
    :return:
    :rtype:
    &#34;&#34;&#34;
    if bound == LOWER_BOUND:
        f = compute_lower_bound
    elif bound == UPPER_BOUND:
        f = compute_upper_bound
    elif bound == EXPECTATION:
        f = compute_expected_outcome

    partial_identification_input = {&#39;primary_index&#39;: self.primary_index,
                                    &#39;protected_class_prediction_from_proxies&#39;: None,
                                    &#39;outcome_prediction_from_proxies&#39;: None,
                                    &#39;protected_class_status&#39;: None,
                                    &#39;predicted_outcome&#39;: None}
    if target == &#39;prediction&#39;:
        partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                    self.model_prediction_from_proxies == truth_or_prediction).astype(int)
        partial_identification_input[&#39;predicted_outcome&#39;] = (self.Yhat == truth_or_prediction).astype(int)
    else:
        partial_identification_input[&#39;outcome_prediction_from_proxies&#39;] = (
                    self.Y_from_proxies == truth_or_prediction).astype(int)
        partial_identification_input[&#39;predicted_outcome&#39;] = (self.Y == truth_or_prediction).astype(int)

    if in_class:
        partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                    self.protected_class_prob[protected_class_name]).astype(int)
        partial_identification_input[&#39;protected_class_status&#39;] = (
                    self.protected_class_membership[protected_class_name]).astype(int)
    else:
        partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;] = (
                    1 - self.protected_class_prob[protected_class_name]).astype(int)
        partial_identification_input[&#39;protected_class_status&#39;] = (
                    1 - self.protected_class_membership[protected_class_name]).astype(int)

    return f(partial_identification_input[&#39;primary_index&#39;],
             partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
             partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
             partial_identification_input[&#39;protected_class_status&#39;],
             partial_identification_input[&#39;predicted_outcome&#39;],
             )</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.partial_identification_quadrant_bounds_for_protected_class"><code class="name flex">
<span>def <span class="ident">partial_identification_quadrant_bounds_for_protected_class</span></span>(<span>self, protected_class_name, bound, truth, predicted, in_class=True)</span>
</code></dt>
<dd>
<div class="desc"><p>:param protected_class_name:
:type protected_class_name:
:param bound:
:type bound:
:param truth:
:type truth:
:param predicted:
:type predicted:
:param in_class:
:type in_class:
:return:
:rtype:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partial_identification_quadrant_bounds_for_protected_class(self, protected_class_name, bound, truth, predicted, in_class=IN_PROTECTED_CLASS):
    &#34;&#34;&#34;

    :param protected_class_name:
    :type protected_class_name:
    :param bound:
    :type bound:
    :param truth:
    :type truth:
    :param predicted:
    :type predicted:
    :param in_class:
    :type in_class:
    :return:
    :rtype:
    &#34;&#34;&#34;
    if bound == LOWER_BOUND:
        f = compute_lower_bound
    elif bound == UPPER_BOUND:
        f = compute_upper_bound
    elif bound == EXPECTATION:
        f = compute_expected_outcome
    if in_class:
        partial_identification_input = {
            &#39;primary_index&#39;: self.primary_index,
            &#39;protected_class_prediction_from_proxies&#39;:self.protected_class_prob[protected_class_name],
            &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
            &#39;protected_class_status&#39;:self.protected_class_membership[protected_class_name],
            &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
        }
    else:
        partial_identification_input = {
            &#39;primary_index&#39;: self.primary_index,
            &#39;protected_class_prediction_from_proxies&#39;:1  - self.protected_class_prob[protected_class_name],
            &#39;outcome_prediction_from_proxies&#39;:self.quadrant_dict[(truth, predicted)],
            &#39;protected_class_status&#39;:1 - self.protected_class_membership[protected_class_name],
            &#39;predicted_outcome&#39;:(self.Yhat == predicted) &amp; (self.Y == truth)
        }
    return f(partial_identification_input[&#39;primary_index&#39;],
             partial_identification_input[&#39;protected_class_prediction_from_proxies&#39;],
             partial_identification_input[&#39;outcome_prediction_from_proxies&#39;],
             partial_identification_input[&#39;protected_class_status&#39;],
             partial_identification_input[&#39;predicted_outcome&#39;],
             )</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_disparity"><code class="name flex">
<span>def <span class="ident">positive_or_negative_hemisphere_disparity</span></span>(<span>self, protected_class, comparison_class='others', variable='prediction', value=1)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def positive_or_negative_hemisphere_disparity(self, protected_class, comparison_class=OTHERS, variable=MODEL_PREDICTION, value=POSITIVE):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.positive_or_negative_hemisphere_disparity(self.hemisphere_readings,protected_class, comparison_class, variable, value)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_reading"><code class="name flex">
<span>def <span class="ident">positive_or_negative_hemisphere_reading</span></span>(<span>self, protected_class, result=1, variable='prediction', within_protected_class=True)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def positive_or_negative_hemisphere_reading(self, protected_class, result=POSITIVE, variable=MODEL_PREDICTION,
                      within_protected_class=True):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.positive_or_negative_hemisphere_reading(self.hemisphere_readings, protected_class, result, variable,
                                                           within_protected_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.ppv_disparity"><code class="name flex">
<span>def <span class="ident">ppv_disparity</span></span>(<span>self, protected_class, comparison_class='others')</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppv_disparity(self, protected_class, comparison_class=OTHERS):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.ppv_disparity(self.ppv_npv, protected_class, comparison_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.ppv_reading"><code class="name flex">
<span>def <span class="ident">ppv_reading</span></span>(<span>self, protected_class)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ppv_reading(self, protected_class):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.ppv_reading(self.ppv_npv, protected_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.tnr_disparity"><code class="name flex">
<span>def <span class="ident">tnr_disparity</span></span>(<span>self, protected_class, comparison_class='others')</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tnr_disparity(self, protected_class, comparison_class=OTHERS):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.tnr_disparity(self.tpr_tnr, protected_class, comparison_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.tnr_reading"><code class="name flex">
<span>def <span class="ident">tnr_reading</span></span>(<span>self, protected_class)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tnr_reading(self, protected_class):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.tnr_reading(self.tpr_tnr, protected_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.tpr_disparity"><code class="name flex">
<span>def <span class="ident">tpr_disparity</span></span>(<span>self, protected_class, comparison_class='others')</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tpr_disparity(self, protected_class, comparison_class=OTHERS):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict(zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.tpr_disparity(self.tpr_tnr, protected_class, comparison_class)))</code></pre>
</details>
</dd>
<dt id="fairness.PartialIdentification.PartialIdentification.tpr_reading"><code class="name flex">
<span>def <span class="ident">tpr_reading</span></span>(<span>self, protected_class)</span>
</code></dt>
<dd>
<div class="desc"><p>For documentation of the below see metrics.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tpr_reading(self, protected_class):
    &#34;&#34;&#34;For documentation of the below see metrics.py&#34;&#34;&#34;
    return dict((zip((&#39;lower_bound&#39;,&#39;expected_value&#39;,&#39;upper_bound&#39;),
                    metrics.tpr_reading(self.tpr_tnr, protected_class))))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fairness" href="index.html">fairness</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fairness.PartialIdentification.PartialIdentification" href="#fairness.PartialIdentification.PartialIdentification">PartialIdentification</a></code></h4>
<ul class="">
<li><code><a title="fairness.PartialIdentification.PartialIdentification.build_estimators_from_proxies" href="#fairness.PartialIdentification.PartialIdentification.build_estimators_from_proxies">build_estimators_from_proxies</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_disparity" href="#fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_disparity">confusion_matrix_quadrant_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_reading" href="#fairness.PartialIdentification.PartialIdentification.confusion_matrix_quadrant_reading">confusion_matrix_quadrant_reading</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.generate_binary_classification_quadrants" href="#fairness.PartialIdentification.PartialIdentification.generate_binary_classification_quadrants">generate_binary_classification_quadrants</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.generate_hemisphere_statistics_by_protected_class" href="#fairness.PartialIdentification.PartialIdentification.generate_hemisphere_statistics_by_protected_class">generate_hemisphere_statistics_by_protected_class</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.generate_quadrant_statistics_by_protected_class" href="#fairness.PartialIdentification.PartialIdentification.generate_quadrant_statistics_by_protected_class">generate_quadrant_statistics_by_protected_class</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.generate_tpr_tnr_ppv_npv_by_protected_class" href="#fairness.PartialIdentification.PartialIdentification.generate_tpr_tnr_ppv_npv_by_protected_class">generate_tpr_tnr_ppv_npv_by_protected_class</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.npv_disparity" href="#fairness.PartialIdentification.PartialIdentification.npv_disparity">npv_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.npv_reading" href="#fairness.PartialIdentification.PartialIdentification.npv_reading">npv_reading</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.partial_identification_hemisphere_bounds_for_protected_class" href="#fairness.PartialIdentification.PartialIdentification.partial_identification_hemisphere_bounds_for_protected_class">partial_identification_hemisphere_bounds_for_protected_class</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.partial_identification_quadrant_bounds_for_protected_class" href="#fairness.PartialIdentification.PartialIdentification.partial_identification_quadrant_bounds_for_protected_class">partial_identification_quadrant_bounds_for_protected_class</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_disparity" href="#fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_disparity">positive_or_negative_hemisphere_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_reading" href="#fairness.PartialIdentification.PartialIdentification.positive_or_negative_hemisphere_reading">positive_or_negative_hemisphere_reading</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.ppv_disparity" href="#fairness.PartialIdentification.PartialIdentification.ppv_disparity">ppv_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.ppv_reading" href="#fairness.PartialIdentification.PartialIdentification.ppv_reading">ppv_reading</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.tnr_disparity" href="#fairness.PartialIdentification.PartialIdentification.tnr_disparity">tnr_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.tnr_reading" href="#fairness.PartialIdentification.PartialIdentification.tnr_reading">tnr_reading</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.tpr_disparity" href="#fairness.PartialIdentification.PartialIdentification.tpr_disparity">tpr_disparity</a></code></li>
<li><code><a title="fairness.PartialIdentification.PartialIdentification.tpr_reading" href="#fairness.PartialIdentification.PartialIdentification.tpr_reading">tpr_reading</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>